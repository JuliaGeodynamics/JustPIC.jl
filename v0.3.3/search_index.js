var documenterSearchIndex = {"docs":
[{"location":"particles/#Memory-layout","page":"Memory layout","title":"Memory layout","text":"","category":"section"},{"location":"particles/","page":"Memory layout","title":"Memory layout","text":"Particles stored in CellArrays objects from CellArrays.jl and are constantly sorted by their parent cell to avoid a loss of spatial locality with time.","category":"page"},{"location":"particles/#Particle-objects","page":"Memory layout","title":"Particle objects","text":"","category":"section"},{"location":"particles/#Particles","page":"Memory layout","title":"Particles","text":"","category":"section"},{"location":"particles/#Passive-markers","page":"Memory layout","title":"Passive markers","text":"","category":"section"},{"location":"particles/#Marker-chain","page":"Memory layout","title":"Marker chain","text":"","category":"section"},{"location":"field_advection2D/#Field-advection-in-2D","page":"Field advection in 2D","title":"Field advection in 2D","text":"","category":"section"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"First we load JustPIC","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"using JustPIC","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"and the correspondent 2D module (we could also use 3D by loading JustPIC._3D)","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"using JustPIC._2D","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"We need to specify what backend are we running our simulation on. For convenience we define the backend as a constant. In this case we use the CPU backend, but we could also use the CUDA (CUDABackend) or AMDGPU (AMDGPUBackend) backends.","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"const backend = JustPIC.CPUBackend","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"we define an analytical flow solution to advected our particles","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"vx_stream(x, y) =  250 * sin(π*x) * cos(π*y)\nvy_stream(x, y) = -250 * cos(π*x) * sin(π*y)","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"define the model domain","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"n  = 256        # number of nodes\nnx = ny = n-1   # number of cells in x and y\nLx = Ly = 1.0   # domain size\nxvi = xv, yv = range(0, Lx, length=n), range(0, Ly, length=n) # cell vertices\nxci = xc, yc = range(0+dx/2, Lx-dx/2, length=n-1), range(0+dy/2, Ly-dy/2, length=n-1) # cell centers\ndxi = dx, dy = xv[2] - xv[1], yv[2] - yv[1] # cell size","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"JustPIC uses staggered grids for the velocity field, so we need to define the staggered grid for Vx and Vy. We","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"grid_vx = xv, expand_range(yc) # staggered grid for Vx\ngrid_vy = expand_range(xc), yv # staggered grid for Vy","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"where expand_range is a helper function that extends the range of a 1D array by one cell size in each direction","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"function expand_range(x::AbstractRange)\n    dx = x[2] - x[1]\n    n = length(x)\n    x1, x2 = extrema(x)\n    xI = round(x1-dx; sigdigits=5)\n    xF = round(x2+dx; sigdigits=5)\n    range(xI, xF, length=n+2)\nend","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"Next we initialize the particles","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"nxcell    = 24 # initial number of particles per cell\nmax_xcell = 48 # maximum number of particles per cell\nmin_xcell = 14 # minimum number of particles per cell\nparticles = init_particles(\n    backend, nxcell, max_xcell, min_xcell, xvi..., dxi..., nx, ny\n)","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"and the velocity and field we want to advect (on the staggered grid)","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"Vx = TA(backend)([vx_stream(x, y) for x in grid_vx[1], y in grid_vx[2]]);\nVy = TA(backend)([vy_stream(x, y) for x in grid_vy[1], y in grid_vy[2]]);\nT  = TA(backend)([y for x in xv, y in yv]); # defined at the cell vertices\nV  = Vx, Vy;\nnothing #hide","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"where TA(backend) will move the data to the specified backend (CPU, CUDA, or AMDGPU)","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"We also need to initialize the field T on the particles","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"particle_args = pT, = init_cell_arrays(particles, Val(1));\nnothing #hide","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"and we can use the function grid2particle! to interpolate the field T to the particles","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"grid2particle!(pT, xvi, T, particles);\nnothing #hide","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"we can now start the simulation","category":"page"},{"location":"field_advection2D/","page":"Field advection in 2D","title":"Field advection in 2D","text":"dt = min(dx / maximum(abs.(Array(Vx))),  dy / maximum(abs.(Array(Vy))));\nniter = 250\nfor it in 1:niter\n    advection!(particles, RungeKutta2(), V, (grid_vx, grid_vy), dt) # advect particles\n    move_particles!(particles, xvi, particle_args)                  # move particles in the memory\n    inject_particles!(particles, (pT, ), xvi)                       # inject particles if needed\n    particle2grid!(T, pT, xvi, particles)                           # interpolate particles to the grid\nend","category":"page"},{"location":"field_advection3D/#Field-advection-in-3D","page":"Field advection in 3D","title":"Field advection in 3D","text":"","category":"section"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"First we load JustPIC","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"using JustPIC","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"and the correspondent 3D module","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"using JustPIC._3D","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"We need to specify what backend are we running our simulation on. For convenience we define the backend as a constant. In this case we use the CPU backend, but we could also use the CUDA (CUDABackend) or AMDGPU (AMDGPUBackend) backends.","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"const backend = JustPIC.CPUBackend","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"we define an analytical flow solution to advected our particles","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"vx_stream(x, z) =  250 * sin(π*x) * cos(π*z)\nvy_stream(x, z) =  0.0\nvz_stream(x, z) = -250 * cos(π*x) * sin(π*z)","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"define the model domain","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"n  = 64             # number of nodes\nnx  = ny = nz = n-1 # number of cells in x and y\nLx  = Ly = Lz = 1.0 # domain size\nni  = nx, ny, nz\nLi  = Lx, Ly, Lz\n\nxvi = xv, yv, zv = ntuple(i -> range(0, Li[i], length=n), Val(3)) # cell vertices\nxci = xc, yc, zc = ntuple(i -> range(0+dxi[i]/2, Li[i]-dxi[i]/2, length=ni[i]), Val(3)) # cell centers\ndxi = dx, dy, dz = ntuple(i -> xvi[i][2] - xvi[i][1], Val(3)) # cell size","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"JustPIC uses staggered grids for the velocity field, so we need to define the staggered grid for Vx and Vy. We","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"grid_vx = xv              , expand_range(yc), expand_range(zc) # staggered grid for Vx\ngrid_vy = expand_range(xc), yv              , expand_range(zc) # staggered grid for Vy\ngrid_vz = expand_range(xc), expand_range(yc), zv               # staggered grid for Vy","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"where expand_range is a helper function that extends the range of a 1D array by one cell size in each direction","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"function expand_range(x::AbstractRange)\n    dx = x[2] - x[1]\n    n = length(x)\n    x1, x2 = extrema(x)\n    xI = round(x1-dx; sigdigits=5)\n    xF = round(x2+dx; sigdigits=5)\n    range(xI, xF, length=n+2)\nend","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"Next we initialize the particles","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"nxcell    = 24 # initial number of particles per cell\nmax_xcell = 48 # maximum number of particles per cell\nmin_xcell = 14 # minimum number of particles per cell\nparticles = init_particles(\n    backend, nxcell, max_xcell, min_xcell, xvi, dxi, ni\n)","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"and the velocity and field we want to advect (on the staggered grid)","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"Vx = TA(backend)([vx_stream(x, z) for x in grid_vx[1], y in grid_vx[2], z in grid_vx[3]])\nVy = TA(backend)([vy_stream(x, z) for x in grid_vy[1], y in grid_vy[2], z in grid_vy[3]])\nVz = TA(backend)([vz_stream(x, z) for x in grid_vz[1], y in grid_vz[2], z in grid_vz[3]])\nT  = TA(backend)([z for x in xv, y in yv, z in zv]) # defined at the cell vertices\nV  = Vx, Vy, Vz","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"where TA(backend) will move the data to the specified backend (CPU, CUDA, or AMDGPU)","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"We also need to initialize the field T on the particles","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"particle_args = pT, = init_cell_arrays(particles, Val(1));","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"and we can use the function grid2particle! to interpolate the field T to the particles","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"grid2particle!(pT, xvi, T, particles)","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"we can now start the simulation","category":"page"},{"location":"field_advection3D/","page":"Field advection in 3D","title":"Field advection in 3D","text":"dt = min(dx / maximum(abs.(Vx)), dy / maximum(abs.(Vy)), dz / maximum(abs.(Vz))) / 2\n\nniter = 250\nfor it in 1:niter\n    advection!(particles, RungeKutta2(), V, (grid_vx, grid_vy, grid_vz), dt) # advect particles\n    move_particles!(particles, xvi, particle_args)                           # move particles in the memory\n    inject_particles!(particles, (pT, ), xvi)                                # inject particles if needed\n    particle2grid!(T, pT, xvi, particles)                                    # interpolate particles to the grid\nend","category":"page"},{"location":"#JustPIC.jl","page":"Home","title":"JustPIC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Particle-in-Cell advection for large scale multi-XPU simulations","category":"page"},{"location":"CellArrays/#Working-with-CellArrays","page":"CellArrays","title":"Working with CellArrays","text":"","category":"section"},{"location":"CellArrays/#Instantiating-a-CellArray","page":"CellArrays","title":"Instantiating a CellArray","text":"","category":"section"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"With the help of ParallelStencil.jl we can easily create a CellArray object. The CellArray object is a container that holds the data of a grid. The data is stored in small nD-arrays, and the grid is divided into cells. Each cell contains a number of elements. The CellArray object is used to store the data of the particles in the simulation.","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"using JustPIC, JustPIC._2D\nusing ParallelStencil\n@init_parallel_stencil(Threads, Float64, 2)","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"julia> ni = (2, 2)\n(2, 2)\n\njulia> ncells = (2,)\n(2,)\n\njulia> x = 20\n20\n\njulia> CA = @fill(x, ni..., celldims = ncells, eltype = Float64) \n2×2 CellArrays.CPUCellArray{StaticArraysCore.SVector{2, Float64}, 2, 1, Float64}:\n [20.0, 20.0]  [20.0, 20.0]\n [20.0, 20.0]  [20.0, 20.0]","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"We can access to the data of one CellArray by indexing a given grid cell. This will however instantiate a StaticArray object with the data of the cell. ","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"julia> CA[1,1]\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 20.0\n 20.0","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"It is however useful to read and mutate the data of the CellArray object directly, without going through the StaticArray object. For this porpuse, JustPIC provides the macro @cell that allows to directly access and mutate the individual elements of the cell. ","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"For example, to read an individual of the CA:","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"julia> @cell CA[2, 1, 1]\n20.0","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"where, in this case, the first index corresponds to the 2nd element of the data within the [1, 1] cell. We can mutate the CellArray in a similar way:","category":"page"},{"location":"CellArrays/","page":"CellArrays","title":"CellArrays","text":"julia> @cell CA[2, 1, 1] = 0.0\n0.0\n\njulia> CA\n2×2 CellArrays.CPUCellArray{StaticArraysCore.SVector{2, Float64}, 2, 1, Float64}:\n [20.0, 0.0]   [20.0, 20.0]\n [20.0, 20.0]  [20.0, 20.0]","category":"page"},{"location":"API/#API","page":"Public API","title":"API","text":"","category":"section"},{"location":"API/","page":"Public API","title":"Public API","text":"JustPIC._2D.setelement!\nJustPIC._3D.element\nJustPIC._3D.setelement!\nJustPIC._3D.@idx\nJustPIC._2D.@idx\nJustPIC._2D.element\nJustPIC._3D.lerp\nJustPIC._2D.lerp","category":"page"},{"location":"API/#JustPIC._2D.setelement!","page":"Public API","title":"JustPIC._2D.setelement!","text":"setelement!(A, x, element_indices..., cell_indices...)\n\nStore the given value x at the given element with element_indices of the cell with the indices cell_indices\n\nArguments\n\nx::Number: value to be stored in the index element_indices of the cell with cell_indices.\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"function"},{"location":"API/#JustPIC._3D.element","page":"Public API","title":"JustPIC._3D.element","text":"element(A, element_indices..., cell_indices...)\n\nReturn a the element with element_indices of the Cell with cell_indices of the CellArray A.\n\nArguments\n\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"function"},{"location":"API/#JustPIC._3D.setelement!","page":"Public API","title":"JustPIC._3D.setelement!","text":"setelement!(A, x, element_indices..., cell_indices...)\n\nStore the given value x at the given element with element_indices of the cell with the indices cell_indices\n\nArguments\n\nx::Number: value to be stored in the index element_indices of the cell with cell_indices.\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"function"},{"location":"API/#JustPIC._3D.@idx","page":"Public API","title":"JustPIC._3D.@idx","text":"@idx(args...)\n\nMake a linear range from 1 to args[i], with i ∈ [1, ..., n]\n\n\n\n\n\n","category":"macro"},{"location":"API/#JustPIC._2D.@idx","page":"Public API","title":"JustPIC._2D.@idx","text":"@idx(args...)\n\nMake a linear range from 1 to args[i], with i ∈ [1, ..., n]\n\n\n\n\n\n","category":"macro"},{"location":"API/#JustPIC._2D.element","page":"Public API","title":"JustPIC._2D.element","text":"element(A, element_indices..., cell_indices...)\n\nReturn a the element with element_indices of the Cell with cell_indices of the CellArray A.\n\nArguments\n\nelement_indices::Int|NTuple{N,Int}: the element_indices that designate the field in accordance with A's cell type.\ncell_indices::Int|NTuple{N,Int}: the cell_indices that designate the cell in accordance with A's cell type.\n\n\n\n\n\n","category":"function"},{"location":"API/#JustPIC._3D.lerp","page":"Public API","title":"JustPIC._3D.lerp","text":"lerp(t, v0, v1)\n\nLinearly interpolates between v0 and v1 using the parameter t.\n\nArguments\n\nt: The interpolation parameter.\nv0: The starting value.\nv1: The ending value.\n\n\n\n\n\nlerp(v, t::NTuple{nD,T}) where {nD,T}\n\nLinearly interpolates the value v between the elements of the tuple t. This function is specialized for tuples of length nD.\n\nArguments\n\nv: The value to be interpolated.\nt: The tuple of values to interpolate between.\n\n\n\n\n\n","category":"function"},{"location":"API/#JustPIC._2D.lerp","page":"Public API","title":"JustPIC._2D.lerp","text":"lerp(t, v0, v1)\n\nLinearly interpolates between v0 and v1 using the parameter t.\n\nArguments\n\nt: The interpolation parameter.\nv0: The starting value.\nv1: The ending value.\n\n\n\n\n\nlerp(v, t::NTuple{nD,T}) where {nD,T}\n\nLinearly interpolates the value v between the elements of the tuple t. This function is specialized for tuples of length nD.\n\nArguments\n\nv: The value to be interpolated.\nt: The tuple of values to interpolate between.\n\n\n\n\n\n","category":"function"}]
}
